// This package (domain) represents the Business domain in the diagram.
// Hexagonal architecture: User - Business - Server


/* 1. Business object */
// inside the domain, hence inside this package

/* 2. repo i.e. secondary port (facing Server) i.e. interface */
// on the boundary of the domain, hence inside this package?
//      or because Business object has dependency on it?
// function: find all customers from Server side

/* 3. stub i.e. adapter (facing Server) */
// implements repo which is inside the domain, hence inside this package?
//      different ways of grouping into packages? it could be in a separate package e.g. test package?
// function: stubbing the actual repo (contains list of dummy customers, its implementation of FindAll() returns this list inside itself)
// notes: mock is for behaviour testing, stub is to simulate or act as dummy data?
// notes: stub implements repo i.e. interface (duck typing) by implementing FindAll(), hence becomes type repo

/* 4a. service i.e. primary port (facing User) i.e. interface */
// different package (service)
// function: get all customers
//		4b. Business logic implements service = another Business object
//		4c. this Business object also has dependency on repo (instead of implementing repo directly)
// function: connect primary port to secondary port

/* 5. REST handler i.e. adapter (facing User) */        // already done actually: handlers#customersHandler
// outside the domain, hence different package (app)
// function: handle requests to "customers" route
//		6. REST handler has dependency on service
//		7. wire the app (REST handler - service - Business logic - repo - stub)


/* 1. to 3. */
// find all customers from the repository (which retrieves from db)
// create dummy repo
// can now call FindAll() on dummy repo to get dummy data

/* 4. */
// service: user side now has a way to get all customers via finding all customers from the repo
// create default service
// can now create default service passing in dummy repo and call GetAllCustomers() on default service to get dummy data     /* 5., 7. */

/* customer.go --> customerRepositoryStub.go --> customerService.go --> handlers.go */
//struct containing detail of 1 customer --> struct containing slice of customers --> struct containing repo --> struct containing service
