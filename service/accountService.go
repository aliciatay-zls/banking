package service

import (
	"github.com/aliciatay-zls/banking/domain"
	"github.com/aliciatay-zls/banking/dto"
	"github.com/aliciatay-zls/banking/errs"
	"time"
)

type AccountService interface { //service (primary port)
	CreateNewAccount(dto.NewAccountRequest) (*dto.NewAccountResponse, *errs.AppError)
	MakeTransaction(dto.TransactionRequest) (*dto.TransactionResponse, *errs.AppError)
}

type DefaultAccountService struct { //business/domain object
	repo domain.AccountRepository //Business Domain has dependency on repo (repo is a field)
}

func NewAccountService(repo domain.AccountRepository) DefaultAccountService {
	return DefaultAccountService{repo}
}

func (s DefaultAccountService) CreateNewAccount(request dto.NewAccountRequest) (*dto.NewAccountResponse, *errs.AppError) { //Business Domain implements service
	if err := request.Validate(); err != nil {
		return nil, err
	}

	account := domain.Account{
		AccountId:   "", //to be generated by db later
		CustomerId:  request.CustomerId,
		OpeningDate: time.Now().Format("2006-01-02 15:04:05"), //from time.RFC3339, modified based on banking.sql
		AccountType: request.AccountType,
		Amount:      request.Amount,
		Status:      "1", //default for newly-created account
	}

	a, err := s.repo.Save(account)
	if err != nil {
		return nil, err
	}

	response := a.ToNewAccountResponseDTO()

	return &response, nil
}

// MakeTransaction checks whether the values in the given request's body are valid, whether the given account exists,
// and whether the current account balance allows for the request to be fulfilled. If so, it passes the request down
// to the server side as an Account object and passes the returned Account DTO back up to the REST handler.
func (s DefaultAccountService) MakeTransaction(request dto.TransactionRequest) (*dto.TransactionResponse, *errs.AppError) { //Business Domain implements service
	if err := request.Validate(); err != nil {
		return nil, err
	}

	account, err := s.repo.FindById(request.AccountId)
	if err != nil {
		return nil, err
	}

	if request.TransactionType == "withdrawal" {
		if !account.CanWithdraw(request.Amount) {
			return nil, errs.NewValidationError("Account balance insufficient to withdraw given amount")
		}
	}

	transaction := domain.Transaction{
		AccountId:       request.AccountId,
		Amount:          request.Amount,
		TransactionType: request.TransactionType,
		TransactionDate: time.Now().Format("2006-01-02 15:04:05"),
	}

	completedTransaction, err := s.repo.Transact(transaction)
	if err != nil {
		return nil, err
	}

	response := completedTransaction.ToTransactionResponseDTO()

	return response, nil
}
